---
title: Surfaces
packages:
  - retil-interactions
---

# <Title />

Surfaces are like "Behavior Components" – they let you apply behaviors to styled components, *without* coupling those styled components to the behavior implementation.

More specifically, a surface is a component that takes some action in response to pointer events, which can disable this action through a `disabled` prop, and which may or may not be focusable. Surfaces are typically unstyled, but allow child components to target behavioral states including "disabled", "focus", and "hover" through *surface selectors*.

Of course, the best way to understand surfaces is to see them in action, so let's dive right into an example.


## The most common surface you'll use.

`<ButtonSurface>` is a component that behaves, well, a lot like a button. It can accept focus, like a button. It supports a `disabled` prop, like a button. And when you click it or press your *enter* key on it, so long as it's enabled, it's `onTrigger` handler will be called – just like a button.

```tsx
import { ButtonSurface } from 'retil-interaction'

render(
  <ButtonSurface onTrigger={() => alert('You clicked me!')}>
    Click Me!
  </ButtonSurface>
)
```

However, *unlike* a button, `<ButtonSurface>` wraps its children with a context provider that makes it possible to use *surface selectors* in its own or its children's styles.

What *are* surface selectors? They're just functions like `inHoveredSurface` or `inFocusedSurface` that you can use to wrap  your styled-components or emotion `css` tagged templates – and which will typically then add a selector to those styles that targets the appropriate pseudo-selector on the appropriate element.

Again, this will all make more sense with an example, so let's take a look at how to generate hover styles for your button using `inHoveredSurface`.

```tsx
import styled, { css } from 'styled-components'
import { ButtonSurface, inHoveredSurface } from 'retil-interaction'

const ButtonBody = styled.div(
  css`
    border: 1px solid black;
    color: black;
    margin: 16px;
    text-decoration: none;
  `,
  inHoveredSurface(css`
    border-color: red;
  `),
)

render(
  <ButtonSurface onPress={() => alert('You clicked me!')}>
    <ButtonBody>
      Click me!
    </ButtonBody>
  </ButtonSurface>
)
```

Can you see how `inHoveredSurface` wraps a css tagged template? This let's the browser know that the `border-color: red;` styles should only apply when the user hovers the mouse over the button *surface*. I want to repeat that, because it's important: `inHoveredSurface` styles will apply whenever the mouse is over the `<ButtonSurface>` element – *even if it's not over the `<ButtonBody>` itself!* In this example, this means that the styles will apply even while the mouse is over the `<ButtonBody>` margin. *But how does this work?*

If you look at the code generated by the above example, you'll see that `<ButtonBody>` generates CSS that looks something like this:

```css
.rx-0:hover .ButtonBody-abcde {
  border-color: red;
}
```

See that `.rx-0`? That's a HTML class that `<ButtonSurface>` will render on the button element itself, and will then add to the React context in such a way that surface selectors like `inHoveredSurface` can find and use it – even during SSR.

And speaking of the rendered button element, curiously, `<ButtonSurface>` doesn't actually render a `<button>` element. Instead, it renders a `<div role="button">` element. And while this creates a bit of extra implementation work for the library authors, there's a good reason to go to the effort, and that is that `<button>` elements don't really support `display: flex;` correctly. By using a `<div>` instead, your button bodies will work just as you expect them to – no matter *which* type of surface you use them in.

And yes, you *will* want to re-use your button bodies. Let me show you how.


## The other most common surface you'll use.

`<LinkSurface href>` is a component that behaves, well, a lot like a link. It can accept focus, like a link. It supports a `disabled` prop – which `<a>` tags don't, but hey, why not. Importantly though, when you click a `<LinkSurface>` or press your *enter* key on it, so long as it's enabled, it'll navigate you to the specified href using retil-nav.

```tsx
import { LinkSurface } from 'retil-interaction'

render(
  <LinkSurface href="/">
    Go home
  </LinkSurface>
)
```

If you've used the Next.js or react-router `<Link>` components before, then `<LinkSurface>` will probably feel familiar. Of course, only `<LinkSurface>` supports surface selectors. But why is this so useful?

Well, say that you have a button, but you want to make it behave like a link. Or you have a link and want to make it look like a button. Either way, you can just use a `<LinkSurface>` to wrap your already-made `<ButtonBody>`, and it just works – pseudo-styles and all!

```tsx
render(
  <LinkSurface href="/">
    <ButtonBody>
      Go home
    </ButtonBody>
  </LinkSurface>
)
```

To summarize so far: surfaces let you decouple your application's behavior and styling into separate components, increasing re-use while decreasing cognitive load.

But wait, there's more.


## What if you weren't limited to CSS's built-in selectors?

- introduce `<MatchedLinkSurface>` and the `inToggledSurface` selector


## More built-in surfaces

- `<AnchorSurface>`
- `<PopupTriggerSurface>`
- `<SubmitButtonSurface>`


## The Rules of Surfaces

- a surface is some typically unstyled element which has an area in the layout
  which it "owns", with behavior attached to clicks/touches on this area,
  where styles can be applied to the surface itself *and* child elements based
  on the current state.
  retil-interactions exports a number of selectors for typical behaviors,
  including `disabled`, `hover`, `active`, `focused`, etc.
- surfaces have an action in responsive to pointer events. for example,
  navigating, submitting a form, communicating with the server, or if
  nothing else, the surface should be focusable.
- if the surface has an action other than taking focus, it *may* delegate
  delegate focus and keyboard handling elsewhere via their `delegateFocus` prop,
  or it may be that the primary action is to delegate focus to a child.
- disabled surfaces can still receive focus. however, surfaces may be made
  unfocusable by passing a focusable={false} prop, or via `delegateFocus`
- surfaces should expose `focus`, `blur` and `dispatch` functions via ref,
  where dispatch() has the same effect as the primary action. other actions
  may be triggered by passing an action to `dispatch`. `dispatch` is
  asynchronous, and returns a `Promise<void>`. `dispatch` cannot be called
  while a previous dispatch is in progress.

  > surfaces are not necessarily focusable, as their primary action may
    be to redirect focus elsewhere!
  > surfaces can not necessarily have focus delegated elsewhere, as their
    primary action may be to take focus for themselves – in which case
    it doesn't make sense to perform the primary action while redirecting
    focus!

- *all* surfaces can be disabled to prevent their primary action from occuring
- *disabled* surfaces can also set to unfocusable to prevent the surface
  accepting focus, and also prevent it from delegating focus elsewhere
- if a surface where the primary action is to accept focus is disabled, it
  will also become unfocusable, but it will still be able to delegate focus.
  this can be used to delegate focus of a disabled input to a wrapper surface,
  and when *not* disabled, to redirect from the wrapper to the input

... update docs to remove mention of nested surface selectors targeting a single
    surface. it's probably possible to get the same effect with hacks, and implementing
    it will be a PITA. it can be a v2 feature.
 
... for surfaces, why not just use a global `.surface` class to target
    surfaces, instead of applying different classes for different depths?
    and for specific actions, .surface.hover, .surface.focus,
    .surface.localLink, etc.?

    a:
    because we want to be able to target the *deepest* surface parent, so that
    we can have nested surfaces where styles on the nested surface only respond
    to behaviors on *it*, and not its parent.

    .surface:hover .surface:not(:hover) & {
      // this should revert any styles
    }